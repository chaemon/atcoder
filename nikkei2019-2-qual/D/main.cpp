#include <bits/stdc++.h>
using namespace std;

typedef long long Int;

const Int INF = 1e+18;

#define REP(i,n) for(int i=0;i<(int)(n);++i)
// segmenttree, range update, point query
//{{{ SegmentTree<T> st(int n, T unit, function<T(T,T)> append)
template <typename T>
struct SegmentTree { // on monoid
	int n;
	vector<T> a;
	function<T (T,T)> append; // associative
	T unit; // unit
	SegmentTree() = default;
	SegmentTree(int a_n, T a_unit, function<T(T,T)> a_append) {
		n = pow(2,ceil(log2(a_n)));
		a.resize(2*n-1, a_unit);
		unit = a_unit;
		append = a_append;
	}
	T point_get(int i) {
		T ret = unit;
		for (i = i + n; i > 0; i /= 2) {
			ret = append(a[i-1], ret);
			//			a[i-1] = append(a[2*i-1], a[2*i]);
		}
		return ret;
	}
	void range_update(int l, int r, T t) {
		range_update(0, 0, n, l, r, t);
	}
	void range_update(int i, int il, int ir, int l, int r, T t) {
		if (l <= il and ir <= r) {
			a[i] = append(a[i],t);
		} else if (ir <= l or r <= il) {
			return;
		} else {
			range_update(2*i+1, il, (il+ir)/2, l, r, t);
			range_update(2*i+2, (il+ir)/2, ir, l, r, t);
		}
	}
	void set(){

	}
	//{{{ debug functions
	void write_tree(int i,int h,int il,int ir){
		REP(j,h)cout<<" ";
		cout<<a[i]<<endl;
		if(ir-il==1){
			return;
		}else{
			int im = (il+ir)/2;
			write_tree(i*2+1,h+1,il,im);
			write(i*2+2,h+1,im,ir);
		}
	}
	void write_tree(){
		write_tree(0,0,0,n);
	}
	void write(){
		REP(i,n)cout<<point_get(i)<<" ";
		cout<<endl;
	}
	//}}}
	};
	//}}}

void solve(long long N, long long M, std::vector<long long> L, std::vector<long long> R, std::vector<long long> C){
	function<Int(Int,Int)> append = [](Int a, Int b){
		return min(a, b);
	};
	SegmentTree<Int> st(N+1, INF, append);
	vector<pair<pair<Int,Int>, Int> > v;
	for(int i = 0;i < M;i++){
		v.push_back({{L[i], R[i]}, C[i]});
	}
	int i = 0;
	sort(v.begin(), v.end());
	st.range_update(0,1,0);
	for(int u = 0;u < N;u++){
		Int d = st.point_get(u);
//		cerr<<"dist: "<<u<<" "<<d<<endl;
		if(u == N - 1){
			if(d == INF){
				cout<<-1<<endl;
			}else{
				cout<<d<<endl;
			}
			break;
		}
		while(i < v.size() and v[i].first.first == u){
//			cerr<<"road: "<<v[i].first.first<<" "<<v[i].first.second<<" "<<v[i].second<<endl;
			Int L = v[i].first.first, R = v[i].first.second, C = v[i].second;
			
			st.range_update(L + 1, R + 1, d + C);
			i++;
		}
	}
}

// Generated by 1.1.6 https://github.com/kyuridenamida/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)
int main(){
	long long N;
	scanf("%lld",&N);
	long long M;
	scanf("%lld",&M);
	std::vector<long long> L(M);
	std::vector<long long> R(M);
	std::vector<long long> C(M);
	for(int i = 0 ; i < M ; i++){
		scanf("%lld",&L[i]);
		scanf("%lld",&R[i]);
		scanf("%lld",&C[i]);
		L[i]--;
		R[i]--;
	}
	solve(N, M, std::move(L), std::move(R), std::move(C));
	return 0;
}
